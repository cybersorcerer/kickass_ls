[
	{
		"directive": ".const",
    	"description": "Defines a constant. A constant can't be assigned a new value. Note that not all values are immutable. If you define a constant that points to a list, the content of the list can still change. If you want to make a mutable value immutable, you can use its lock() function, which will lock it's content",
		"signature": ".const constant_name=value",
		"examples": [
			".const x=25 //Defines a constant x with a value of 25"
		]
	},
	{
		"directive": ".var",
    	"description": "Defines a variable. With variables you can store data for later use. Before you can use a variable you have to declare it. You do this with the .var directive",
		"signature": ".var variable_name=value",
		"examples": [
			".var c=1                 // Declares the variable c to be 1",
    	    ".var name = \"MYSTRING\" // Variables can assume any value, for example string"
		]
	},
	{
		"directive": ".eval",
    	"description": "The .eval directive is used to make Kick Assembler evaluate expressions. In fact, the .var directive above is just a convenient shorthand of \".eval var x =25\", where var is a subexpression that declares a variable.",
		"signature": ".eval expression",
		"examples": [
			".eval x=x+10 // Adds 10 to whatever is in variable x",
    	    ".eval x++    // Gives x=x+1",
        	".eval x--    // Gives x=x-1",
        	".eval x+=3   // Gives x=x+3",
        	".eval x-=7   // Gives x=x-7",
        	".eval x*=3   // Gives x=x*3",
        	".eval x/=2   // Gives x=x/2"
		]
	},
	{
		"directive": ".enum",
    	"description": "With the .enum statement you can define enumerations, which are series of constants.",
		"signature": ".enum {value1, value2, valueN}",
		"examples": [
			".enum {singleColor, multiColor}      // Defines singleColor=0, multiColor=1",
			".enum {effect1=1,effect2=2,end=$ff}  // Assigns values explicitly",
			".enum {up,down,left,right, none=$ff} // You can mix implicit and explicit",
			"                                     // assignment of values"
		]
	},
	{
		"directive": ".label",
    	"description": "Label declarations in Kick Assembler end with \":\" and have no postfix when referred to. You can put labels in front of mnemonic arguments. This can be useful when creating self modifying code. Kick Assembler also supports multi labels, which are labels that can be declared more than once. These are useful to prevent name conflicts between labels. A multi label starts with a **!** and when your reference it you have to end with a **+** to refer to the next multi label or **-** to refer to the previous multi label.",
		"signature": "label_name: [instruction]",
		"examples": [
			"loop:   inc $d020",
			"ldx tmpX:#$00"
		]
	},
	{
		"directive": ".byte",
    	"description": "The .byte, .word, .dword and .text directives are used to generate byte, word (one word= two bytes), dword (double word = 4 bytes) and text data as in standard 65xx assemblers.",
		"signature": ".byte bytevalue1, bytevalue2, bytevalueN",
		"examples": [
			".byte 1,2,3,4 // Generates the bytes 1,2,3,4"
		]
	},
	{
		"directive": ".word",
    	"description": "The .byte, .word, .dword and .text directives are used to generate byte, word (one word= two bytes), dword (double word = 4 bytes) and text data as in standard 65xx assemblers.",
		"signature": ".word wordvalue1, wordvalue2, wordvalueN",
		"examples": [
			".word $2000,$1234 // Generates the bytes $00,$20,$34,$12"
		]
	},
	{
		"directive": ".dword",
    	"description": "The .byte, .word, .dword and .text directives are used to generate byte, word (one word= two bytes), dword (double word = 4 bytes) and text data as in standard 65xx assemblers.",
		"examples": [
			".dword $12341234 // Generates the bytes $34,$12,$34,$12"
		]
	},
	{
		"directive": ".text",
    	"description": "The .byte, .word, .dword and .text directives are used to generate byte, word (one word= two bytes), dword (double word = 4 bytes) and text data as in standard 65xx assemblers.",
		"signature": ".text \"string\"",
		"examples": [
			".text \"Hello World\""
		]
	},
	{
		"directive": ".fill",
    	"description": "With the .fill directive you can fill a section of the memory with bytes. It works like a loop and automatically sets the variable i to the iteration number.",
		"signature": ".fill count, value",
		"examples": [
			".fill 5, 0  // Generates byte 0,0,0,0,0",
			".fill 5, i  // Generates byte 0,1,2,3,4",
			".fill 256, 127.5 + 127.5*sin(toRadians(i*360/256)) // Generates a sine curve",
			".fill 4, [$10,$20]             // Generates .byte $10,$20,$10,$20,$10,$20,$10,$20",
			".fill 3, ['D','E','M','O','!'] // Generates the same bytes as .text \"DEMO!DEMO!DEMO!\"",
			".fill 3, [i,i*$10]             // Generates .byte 0,0,1,$10,2,$20"
		]
	},
	{
		"directive": "#import",
    	"description": "Use the preprocessor to import other source files.",
		"signature": "#import file_name",
		"examples": [
			"#import \"MyLibrary.asm\" // Import the file \"mylibrary.asm\""
		]
	},
	{
		"directive": "#importif",
    	"description": "Use the preprocessor to import other source files.",
		"signature": "#importif var/const file_name",
		"examples": [
			"#importif STAND_ALONE \"UpstartCode.asm\" // Only import \"UpstartCode.asm\" if STAND_ALONE is defined"
		]
	},
	{
		"directive": ".import",
    	"description": "With the .import directive you can import data from external files into your code. You can import binary, C64, and text files. The binary, c64 and text import takes an offset and a length as optional parameters.",
		"signature": ".import file_name",
		"examples": [
			".import binary \"Music.bin\" // import the bytes from the file 'music.bin'",
			".import c64 \"charset.c64\" // (Same as binary but skips the first two address bytes)",
			".import binary \"Music.bin\", 100 // import the bytes from the file 'music.bin', but skip the first 100 bytes",
			".import c64 \"charset.c64\", $400, $200 // Imports $200 bytes starting from position $402"
		]
	},
	{
		"directive": ".print",
    	"description": "With the .print directive you can output text to the user while assembling.",
		"signature": ".print \"message text\"",
		"examples": [
			".print \"Hello world\""
		]
	},
	{
		"directive": ".printnow",
    	"description": "You can define your own functions which you can use like any of the build in library functions.",
		"signature": ".printnow \"message text\"",
		"examples": [
			".printnow \"loop=$\" + toHexString(loop)"
		]
	},
	{
		"directive": ".pseudocommand",
    	"description": "Pseudo commands are a special kind of macros that take command arguments, like #20, table,y or ($30),y as arguments just like mnemonics do. With these you can make your own extended commands.",
		"signature": ".pseudocommand command_name arg1:arg3:argN",
		"examples": [
			".pseudocommand mov src:tar {",
    		"   lda src",
    		"   sta tar",
            "}"
		]
	},
	{
		"directive": ".function",
    	"description": "You can define you own functions which you can use like any of the build in library functions. Functions consist of non-byte generating directives like .eval, .for, .var, and .if. When the assembler evaluates the .return directive it returns the value given by the proceeding expression. If no expression is given, or if no .return directive is reached, a null value is returned. You can have several functions of the same name, as long as they have a different number of arguments.",
		"signature": ".function function_name(args) {}",
		"examples": [
			"// Returns a string telling if a number is odd or even",
			".function oddEven(number) {",
    		"   .if ([number&1] == 0 ) .return \"even\"",
    		"   else .return \"odd\"",
			"}"
		]
	},
	{
		"directive": ".namespace",
    	"description": "Namespaces are containers of functions, macros and pseudocommands. There can only be one of each of these entities in namespace. Every namespace also have an its own associated scope so each time you define a namespace a scopes is automatically defined. A simple way to declare a namespace is shown in the following example. The namespace directives is covered in more detail later (and often the .filenamespace directive is more handy)",
		"signature": ".namespace namespace_name {}",
		"examples": [
			".function myFunction() { .return 1 }",
            "label1:",
            ".namespace mySpace {",
            "   .function myFunction() { .return 1 } // <- This won't collide",
            "   label1:  <- This won't collide",
            "}"
		]
	},
	{
		"directive": ".macro",
    	"description": "Macros are collections of assembler directives. When called, they generate code as if the directives where placed at the macro call. A macro can have any number of arguments. Macro calls are encapsulated in a scope, hence any variable defined inside a macro can't be seen from directly the outside. This means that a series of macro calls to the same macro doesn't interfere",
		"signature": ".macro macro_name(macro_parameter) {}",
		"examples": [
			"// Define macro",
			".macro SetColor(color) {",
			"    lda #color",
			"    sta $d020",
			"}",
			"// Execute macro",
			":SetColor(1)",
			"SetColor(2)   // The colon in front of macro calls is optional from version 4.0"
		]
	},
	{
		"directive": ".align",
    	"description": "With the .align directive, you can align the program counter to a given interval. This is useful for optimizing your code as crossing a memory page boundary yields a penalty of one cycle for memory referring commands. To avoid this, use the .align command to align your tables",
		"signature": ".align $address",
		"examples": [
			"        *=$10ff       // Bad place for the data",
			"        .align $100   //Alignment to the nearest page boundary saves a cycle",
			"data:   .byte 1,2,3,4,5,6,7,8"
		]
	},
	{
		"directive": ".assert",
    	"description": "Assert directives are useful for testing. They were made to make it easy to test the assembler itself, but you can use them for testing your own pseudo-commands, macros, functions. When assertions are used, the assembler will automatically count the number of assertions and the number of failed assertions and display these when the assembling has finished. With the assert directive you can test the value of expressions. .assert takes three arguments: a description, an expression, and an expected result.",
		"signature": ".assert description, expression, expected_result",
		"examples": [
			".assert '2+5*10/2', 2+5*10/2, 27",
			".assert '2+2', 2+2, 5",
			".assert 'Vector(1,2,3)+Vector(1,1,1)', Vector(1,2,3)+Vector(1,1,1), Vector(2,3,4)"
		]
	},
	{
		"directive": ".asserterror",
    	"description": "Asserts that a given expression or codeblock generates an error. Like the assert directive the asserterror directive also has a form that can assert code. o make sure that an expression gives an error when the user gives the wrong parameters to a function, use the .asserterror directive.",
		"signature": ".asserterror description, expression",
		"examples": [
			".asserterror 'Test1' , 20/10",
			".asserterror  'Test2' , 20/false",
			".asserterror 'Test 3', List().get(27)"
		]
	},
	{
		"directive": ".break",
    	"description": "The .break directive puts a breakpoint on the current memory position. You can add an argument to a breakpoint. The syntax of this argument is dependant on the consumer. For example .break 'if y<5' is written for VICE's conditional expressions. VICE will then break if the y register is below 5",
		"signature": ".break [condition]",
		"examples": [
			"loop:",
    		"     .break         // This will put a breakpoint on 'inc $d020",
    		"     inc $d020"
		]
	}
]